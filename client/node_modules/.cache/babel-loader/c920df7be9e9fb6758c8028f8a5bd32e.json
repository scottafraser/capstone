{"ast":null,"code":"'use strict';\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nexports.__esModule = true;\nexports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = undefined;\n\nvar _propTypes = require('prop-types');\n\nvar PropTypes = _interopRequireWildcard(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _reactLifecyclesCompat = require('react-lifecycles-compat');\n\nvar _PropTypes = require('./utils/PropTypes');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar UNMOUNTED = exports.UNMOUNTED = 'unmounted';\nvar EXITED = exports.EXITED = 'exited';\nvar ENTERING = exports.ENTERING = 'entering';\nvar ENTERED = exports.ENTERED = 'entered';\nvar EXITING = exports.EXITING = 'exiting';\n/**\n * The Transition component lets you describe a transition from one component\n * state to another _over time_ with a simple declarative API. Most commonly\n * it's used to animate the mounting and unmounting of a component, but can also\n * be used to describe in-place transition states as well.\n *\n * By default the `Transition` component does not alter the behavior of the\n * component it renders, it only tracks \"enter\" and \"exit\" states for the components.\n * It's up to you to give meaning and effect to those states. For example we can\n * add styles to a component when it enters or exits:\n *\n * ```jsx\n * import Transition from 'react-transition-group/Transition';\n *\n * const duration = 300;\n *\n * const defaultStyle = {\n *   transition: `opacity ${duration}ms ease-in-out`,\n *   opacity: 0,\n * }\n *\n * const transitionStyles = {\n *   entering: { opacity: 0 },\n *   entered:  { opacity: 1 },\n * };\n *\n * const Fade = ({ in: inProp }) => (\n *   <Transition in={inProp} timeout={duration}>\n *     {(state) => (\n *       <div style={{\n *         ...defaultStyle,\n *         ...transitionStyles[state]\n *       }}>\n *         I'm a fade Transition!\n *       </div>\n *     )}\n *   </Transition>\n * );\n * ```\n *\n * As noted the `Transition` component doesn't _do_ anything by itself to its child component.\n * What it does do is track transition states over time so you can update the\n * component (such as by adding styles or classes) when it changes states.\n *\n * There are 4 main states a Transition can be in:\n *  - `'entering'`\n *  - `'entered'`\n *  - `'exiting'`\n *  - `'exited'`\n *\n * Transition state is toggled via the `in` prop. When `true` the component begins the\n * \"Enter\" stage. During this stage, the component will shift from its current transition state,\n * to `'entering'` for the duration of the transition and then to the `'entered'` stage once\n * it's complete. Let's take the following example:\n *\n * ```jsx\n * state = { in: false };\n *\n * toggleEnterState = () => {\n *   this.setState({ in: true });\n * }\n *\n * render() {\n *   return (\n *     <div>\n *       <Transition in={this.state.in} timeout={500} />\n *       <button onClick={this.toggleEnterState}>Click to Enter</button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the button is clicked the component will shift to the `'entering'` state and\n * stay there for 500ms (the value of `timeout`) before it finally switches to `'entered'`.\n *\n * When `in` is `false` the same thing happens except the state moves from `'exiting'` to `'exited'`.\n *\n * ## Timing\n *\n * Timing is often the trickiest part of animation, mistakes can result in slight delays\n * that are hard to pin down. A common example is when you want to add an exit transition,\n * you should set the desired final styles when the state is `'exiting'`. That's when the\n * transition to those styles will start and, if you matched the `timeout` prop with the\n * CSS Transition duration, it will end exactly when the state changes to `'exited'`.\n *\n * > **Note**: For simpler transitions the `Transition` component might be enough, but\n * > take into account that it's platform-agnostic, while the `CSSTransition` component\n * > [forces reflows](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)\n * > in order to make more complex transitions more predictable. For example, even though\n * > classes `example-enter` and `example-enter-active` are applied immediately one after\n * > another, you can still transition from one to the other because of the forced reflow\n * > (read [this issue](https://github.com/reactjs/react-transition-group/issues/159#issuecomment-322761171)\n * > for more info). Take this into account when choosing between `Transition` and\n * > `CSSTransition`.\n *\n * ## Example\n *\n * <iframe src=\"https://codesandbox.io/embed/741op4mmj0?fontsize=14\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n *\n */\n\nvar Transition = function (_React$Component) {\n  _inherits(Transition, _React$Component);\n\n  function Transition(props, context) {\n    _classCallCheck(this, Transition);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n    var parentGroup = context.transitionGroup; // In the context of a TransitionGroup all enters are really appears\n\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\n    var initialStatus = void 0;\n    _this.appearStatus = null;\n\n    if (props.in) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.appearStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else {\n      if (props.unmountOnExit || props.mountOnEnter) {\n        initialStatus = UNMOUNTED;\n      } else {\n        initialStatus = EXITED;\n      }\n    }\n\n    _this.state = {\n      status: initialStatus\n    };\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  Transition.prototype.getChildContext = function getChildContext() {\n    return {\n      transitionGroup: null // allows for nested Transitions\n\n    };\n  };\n\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\n    var nextIn = _ref.in;\n\n    if (nextIn && prevState.status === UNMOUNTED) {\n      return {\n        status: EXITED\n      };\n    }\n\n    return null;\n  }; // getSnapshotBeforeUpdate(prevProps) {\n  //   let nextStatus = null\n  //   if (prevProps !== this.props) {\n  //     const { status } = this.state\n  //     if (this.props.in) {\n  //       if (status !== ENTERING && status !== ENTERED) {\n  //         nextStatus = ENTERING\n  //       }\n  //     } else {\n  //       if (status === ENTERING || status === ENTERED) {\n  //         nextStatus = EXITING\n  //       }\n  //     }\n  //   }\n  //   return { nextStatus }\n  // }\n\n\n  Transition.prototype.componentDidMount = function componentDidMount() {\n    this.updateStatus(true, this.appearStatus);\n  };\n\n  Transition.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var nextStatus = null;\n\n    if (prevProps !== this.props) {\n      var status = this.state.status;\n\n      if (this.props.in) {\n        if (status !== ENTERING && status !== ENTERED) {\n          nextStatus = ENTERING;\n        }\n      } else {\n        if (status === ENTERING || status === ENTERED) {\n          nextStatus = EXITING;\n        }\n      }\n    }\n\n    this.updateStatus(false, nextStatus);\n  };\n\n  Transition.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n\n  Transition.prototype.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n    var exit = void 0,\n        enter = void 0,\n        appear = void 0;\n    exit = enter = appear = timeout;\n\n    if (timeout != null && typeof timeout !== 'number') {\n      exit = timeout.exit;\n      enter = timeout.enter;\n      appear = timeout.appear;\n    }\n\n    return {\n      exit: exit,\n      enter: enter,\n      appear: appear\n    };\n  };\n\n  Transition.prototype.updateStatus = function updateStatus() {\n    var mounting = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var nextStatus = arguments[1];\n\n    if (nextStatus !== null) {\n      // nextStatus will always be ENTERING or EXITING.\n      this.cancelNextCallback();\n\n      var node = _reactDom2.default.findDOMNode(this);\n\n      if (nextStatus === ENTERING) {\n        this.performEnter(node, mounting);\n      } else {\n        this.performExit(node);\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({\n        status: UNMOUNTED\n      });\n    }\n  };\n\n  Transition.prototype.performEnter = function performEnter(node, mounting) {\n    var _this2 = this;\n\n    var enter = this.props.enter;\n    var appearing = this.context.transitionGroup ? this.context.transitionGroup.isMounting : mounting;\n    var timeouts = this.getTimeouts(); // no enter animation skip right to ENTERED\n    // if we are mounting and running this it means appear _must_ be set\n\n    if (!mounting && !enter) {\n      this.safeSetState({\n        status: ENTERED\n      }, function () {\n        _this2.props.onEntered(node);\n      });\n      return;\n    }\n\n    this.props.onEnter(node, appearing);\n    this.safeSetState({\n      status: ENTERING\n    }, function () {\n      _this2.props.onEntering(node, appearing); // FIXME: appear timeout?\n\n\n      _this2.onTransitionEnd(node, timeouts.enter, function () {\n        _this2.safeSetState({\n          status: ENTERED\n        }, function () {\n          _this2.props.onEntered(node, appearing);\n        });\n      });\n    });\n  };\n\n  Transition.prototype.performExit = function performExit(node) {\n    var _this3 = this;\n\n    var exit = this.props.exit;\n    var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED\n\n    if (!exit) {\n      this.safeSetState({\n        status: EXITED\n      }, function () {\n        _this3.props.onExited(node);\n      });\n      return;\n    }\n\n    this.props.onExit(node);\n    this.safeSetState({\n      status: EXITING\n    }, function () {\n      _this3.props.onExiting(node);\n\n      _this3.onTransitionEnd(node, timeouts.exit, function () {\n        _this3.safeSetState({\n          status: EXITED\n        }, function () {\n          _this3.props.onExited(node);\n        });\n      });\n    });\n  };\n\n  Transition.prototype.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n\n  Transition.prototype.safeSetState = function safeSetState(nextState, callback) {\n    // This shouldn't be necessary, but there are weird race conditions with\n    // setState callbacks and unmounting in testing, so always make sure that\n    // we can cancel any pending setState callbacks after we unmount.\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, callback);\n  };\n\n  Transition.prototype.setNextCallback = function setNextCallback(callback) {\n    var _this4 = this;\n\n    var active = true;\n\n    this.nextCallback = function (event) {\n      if (active) {\n        active = false;\n        _this4.nextCallback = null;\n        callback(event);\n      }\n    };\n\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n\n    return this.nextCallback;\n  };\n\n  Transition.prototype.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {\n    this.setNextCallback(handler);\n\n    if (node) {\n      if (this.props.addEndListener) {\n        this.props.addEndListener(node, this.nextCallback);\n      }\n\n      if (timeout != null) {\n        setTimeout(this.nextCallback, timeout);\n      }\n    } else {\n      setTimeout(this.nextCallback, 0);\n    }\n  };\n\n  Transition.prototype.render = function render() {\n    var status = this.state.status;\n\n    if (status === UNMOUNTED) {\n      return null;\n    }\n\n    var _props = this.props,\n        children = _props.children,\n        childProps = _objectWithoutProperties(_props, ['children']); // filter props for Transtition\n\n\n    delete childProps.in;\n    delete childProps.mountOnEnter;\n    delete childProps.unmountOnExit;\n    delete childProps.appear;\n    delete childProps.enter;\n    delete childProps.exit;\n    delete childProps.timeout;\n    delete childProps.addEndListener;\n    delete childProps.onEnter;\n    delete childProps.onEntering;\n    delete childProps.onEntered;\n    delete childProps.onExit;\n    delete childProps.onExiting;\n    delete childProps.onExited;\n\n    if (typeof children === 'function') {\n      return children(status, childProps);\n    }\n\n    var child = _react2.default.Children.only(children);\n\n    return _react2.default.cloneElement(child, childProps);\n  };\n\n  return Transition;\n}(_react2.default.Component);\n\nTransition.contextTypes = {\n  transitionGroup: PropTypes.object\n};\nTransition.childContextTypes = {\n  transitionGroup: function transitionGroup() {}\n};\nTransition.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * A `function` child can be used instead of a React element.\n   * This function is called with the current transition status\n   * ('entering', 'entered', 'exiting', 'exited', 'unmounted'), which can be used\n   * to apply context specific props to a component.\n   *\n   * ```jsx\n   * <Transition timeout={150}>\n   *   {(status) => (\n   *     <MyComponent className={`fade fade-${status}`} />\n   *   )}\n   * </Transition>\n   * ```\n   */\n  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,\n\n  /**\n   * Show the component; triggers the enter or exit states\n   */\n  in: PropTypes.bool,\n\n  /**\n   * By default the child component is mounted immediately along with\n   * the parent `Transition` component. If you want to \"lazy mount\" the component on the\n   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay\n   * mounted, even on \"exited\", unless you also specify `unmountOnExit`.\n   */\n  mountOnEnter: PropTypes.bool,\n\n  /**\n   * By default the child component stays mounted after it reaches the `'exited'` state.\n   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.\n   */\n  unmountOnExit: PropTypes.bool,\n\n  /**\n   * Normally a component is not transitioned if it is shown when the `<Transition>` component mounts.\n   * If you want to transition on the first mount set `appear` to `true`, and the\n   * component will transition in as soon as the `<Transition>` mounts.\n   *\n   * > Note: there are no specific \"appear\" states. `appear` only adds an additional `enter` transition.\n   */\n  appear: PropTypes.bool,\n\n  /**\n   * Enable or disable enter transitions.\n   */\n  enter: PropTypes.bool,\n\n  /**\n   * Enable or disable exit transitions.\n   */\n  exit: PropTypes.bool,\n\n  /**\n   * The duration of the transition, in milliseconds.\n   * Required unless `addEndListener` is provided\n   *\n   * You may specify a single timeout for all transitions like: `timeout={500}`,\n   * or individually like:\n   *\n   * ```jsx\n   * timeout={{\n   *  enter: 300,\n   *  exit: 500,\n   * }}\n   * ```\n   *\n   * @type {number | { enter?: number, exit?: number }}\n   */\n  timeout: function timeout(props) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var pt = _PropTypes.timeoutsShape;\n    if (!props.addEndListener) pt = pt.isRequired;\n    return pt.apply(undefined, [props].concat(args));\n  },\n\n  /**\n   * Add a custom transition end trigger. Called with the transitioning\n   * DOM node and a `done` callback. Allows for more fine grained transition end\n   * logic. **Note:** Timeouts are still used as a fallback if provided.\n   *\n   * ```jsx\n   * addEndListener={(node, done) => {\n   *   // use the css transitionend event to mark the finish of a transition\n   *   node.addEventListener('transitionend', done, false);\n   * }}\n   * ```\n   */\n  addEndListener: PropTypes.func,\n\n  /**\n   * Callback fired before the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEnter: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntering: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entered\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEntered: PropTypes.func,\n\n  /**\n   * Callback fired before the \"exiting\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExit: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exiting\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExiting: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exited\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExited: PropTypes.func // Name the function so it is clearer in the documentation\n\n} : {};\n\nfunction noop() {}\n\nTransition.defaultProps = {\n  in: false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n  onEnter: noop,\n  onEntering: noop,\n  onEntered: noop,\n  onExit: noop,\n  onExiting: noop,\n  onExited: noop\n};\nTransition.UNMOUNTED = 0;\nTransition.EXITED = 1;\nTransition.ENTERING = 2;\nTransition.ENTERED = 3;\nTransition.EXITING = 4;\nexports.default = (0, _reactLifecyclesCompat.polyfill)(Transition);","map":{"version":3,"sources":["/Users/Guest/Desktop/capstone/client/node_modules/react-transition-group/Transition.js"],"names":["exports","__esModule","EXITING","ENTERED","ENTERING","EXITED","UNMOUNTED","undefined","_propTypes","require","PropTypes","_interopRequireWildcard","_react","_react2","_interopRequireDefault","_reactDom","_reactDom2","_reactLifecyclesCompat","_PropTypes","obj","default","newObj","key","Object","prototype","hasOwnProperty","call","_objectWithoutProperties","keys","target","i","indexOf","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","Transition","_React$Component","props","context","_this","parentGroup","transitionGroup","appear","isMounting","enter","initialStatus","appearStatus","in","unmountOnExit","mountOnEnter","state","status","nextCallback","getChildContext","getDerivedStateFromProps","_ref","prevState","nextIn","componentDidMount","updateStatus","componentDidUpdate","prevProps","nextStatus","componentWillUnmount","cancelNextCallback","getTimeouts","timeout","exit","mounting","arguments","length","node","findDOMNode","performEnter","performExit","setState","_this2","appearing","timeouts","safeSetState","onEntered","onEnter","onEntering","onTransitionEnd","_this3","onExited","onExit","onExiting","cancel","nextState","callback","setNextCallback","_this4","active","event","handler","addEndListener","setTimeout","render","_props","children","childProps","child","Children","only","cloneElement","Component","contextTypes","object","childContextTypes","propTypes","process","env","NODE_ENV","oneOfType","func","isRequired","element","bool","_len","args","Array","_key","pt","timeoutsShape","apply","concat","noop","defaultProps","polyfill"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = undefined;\n\nvar _propTypes = require('prop-types');\n\nvar PropTypes = _interopRequireWildcard(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _reactLifecyclesCompat = require('react-lifecycles-compat');\n\nvar _PropTypes = require('./utils/PropTypes');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar UNMOUNTED = exports.UNMOUNTED = 'unmounted';\nvar EXITED = exports.EXITED = 'exited';\nvar ENTERING = exports.ENTERING = 'entering';\nvar ENTERED = exports.ENTERED = 'entered';\nvar EXITING = exports.EXITING = 'exiting';\n\n/**\n * The Transition component lets you describe a transition from one component\n * state to another _over time_ with a simple declarative API. Most commonly\n * it's used to animate the mounting and unmounting of a component, but can also\n * be used to describe in-place transition states as well.\n *\n * By default the `Transition` component does not alter the behavior of the\n * component it renders, it only tracks \"enter\" and \"exit\" states for the components.\n * It's up to you to give meaning and effect to those states. For example we can\n * add styles to a component when it enters or exits:\n *\n * ```jsx\n * import Transition from 'react-transition-group/Transition';\n *\n * const duration = 300;\n *\n * const defaultStyle = {\n *   transition: `opacity ${duration}ms ease-in-out`,\n *   opacity: 0,\n * }\n *\n * const transitionStyles = {\n *   entering: { opacity: 0 },\n *   entered:  { opacity: 1 },\n * };\n *\n * const Fade = ({ in: inProp }) => (\n *   <Transition in={inProp} timeout={duration}>\n *     {(state) => (\n *       <div style={{\n *         ...defaultStyle,\n *         ...transitionStyles[state]\n *       }}>\n *         I'm a fade Transition!\n *       </div>\n *     )}\n *   </Transition>\n * );\n * ```\n *\n * As noted the `Transition` component doesn't _do_ anything by itself to its child component.\n * What it does do is track transition states over time so you can update the\n * component (such as by adding styles or classes) when it changes states.\n *\n * There are 4 main states a Transition can be in:\n *  - `'entering'`\n *  - `'entered'`\n *  - `'exiting'`\n *  - `'exited'`\n *\n * Transition state is toggled via the `in` prop. When `true` the component begins the\n * \"Enter\" stage. During this stage, the component will shift from its current transition state,\n * to `'entering'` for the duration of the transition and then to the `'entered'` stage once\n * it's complete. Let's take the following example:\n *\n * ```jsx\n * state = { in: false };\n *\n * toggleEnterState = () => {\n *   this.setState({ in: true });\n * }\n *\n * render() {\n *   return (\n *     <div>\n *       <Transition in={this.state.in} timeout={500} />\n *       <button onClick={this.toggleEnterState}>Click to Enter</button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the button is clicked the component will shift to the `'entering'` state and\n * stay there for 500ms (the value of `timeout`) before it finally switches to `'entered'`.\n *\n * When `in` is `false` the same thing happens except the state moves from `'exiting'` to `'exited'`.\n *\n * ## Timing\n *\n * Timing is often the trickiest part of animation, mistakes can result in slight delays\n * that are hard to pin down. A common example is when you want to add an exit transition,\n * you should set the desired final styles when the state is `'exiting'`. That's when the\n * transition to those styles will start and, if you matched the `timeout` prop with the\n * CSS Transition duration, it will end exactly when the state changes to `'exited'`.\n *\n * > **Note**: For simpler transitions the `Transition` component might be enough, but\n * > take into account that it's platform-agnostic, while the `CSSTransition` component\n * > [forces reflows](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)\n * > in order to make more complex transitions more predictable. For example, even though\n * > classes `example-enter` and `example-enter-active` are applied immediately one after\n * > another, you can still transition from one to the other because of the forced reflow\n * > (read [this issue](https://github.com/reactjs/react-transition-group/issues/159#issuecomment-322761171)\n * > for more info). Take this into account when choosing between `Transition` and\n * > `CSSTransition`.\n *\n * ## Example\n *\n * <iframe src=\"https://codesandbox.io/embed/741op4mmj0?fontsize=14\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n *\n */\n\nvar Transition = function (_React$Component) {\n  _inherits(Transition, _React$Component);\n\n  function Transition(props, context) {\n    _classCallCheck(this, Transition);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n    var parentGroup = context.transitionGroup;\n    // In the context of a TransitionGroup all enters are really appears\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\n\n    var initialStatus = void 0;\n\n    _this.appearStatus = null;\n\n    if (props.in) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.appearStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else {\n      if (props.unmountOnExit || props.mountOnEnter) {\n        initialStatus = UNMOUNTED;\n      } else {\n        initialStatus = EXITED;\n      }\n    }\n\n    _this.state = { status: initialStatus };\n\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  Transition.prototype.getChildContext = function getChildContext() {\n    return { transitionGroup: null // allows for nested Transitions\n    };\n  };\n\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\n    var nextIn = _ref.in;\n\n    if (nextIn && prevState.status === UNMOUNTED) {\n      return { status: EXITED };\n    }\n    return null;\n  };\n\n  // getSnapshotBeforeUpdate(prevProps) {\n  //   let nextStatus = null\n\n  //   if (prevProps !== this.props) {\n  //     const { status } = this.state\n\n  //     if (this.props.in) {\n  //       if (status !== ENTERING && status !== ENTERED) {\n  //         nextStatus = ENTERING\n  //       }\n  //     } else {\n  //       if (status === ENTERING || status === ENTERED) {\n  //         nextStatus = EXITING\n  //       }\n  //     }\n  //   }\n\n  //   return { nextStatus }\n  // }\n\n  Transition.prototype.componentDidMount = function componentDidMount() {\n    this.updateStatus(true, this.appearStatus);\n  };\n\n  Transition.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var nextStatus = null;\n    if (prevProps !== this.props) {\n      var status = this.state.status;\n\n\n      if (this.props.in) {\n        if (status !== ENTERING && status !== ENTERED) {\n          nextStatus = ENTERING;\n        }\n      } else {\n        if (status === ENTERING || status === ENTERED) {\n          nextStatus = EXITING;\n        }\n      }\n    }\n    this.updateStatus(false, nextStatus);\n  };\n\n  Transition.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n\n  Transition.prototype.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n\n    var exit = void 0,\n        enter = void 0,\n        appear = void 0;\n\n    exit = enter = appear = timeout;\n\n    if (timeout != null && typeof timeout !== 'number') {\n      exit = timeout.exit;\n      enter = timeout.enter;\n      appear = timeout.appear;\n    }\n    return { exit: exit, enter: enter, appear: appear };\n  };\n\n  Transition.prototype.updateStatus = function updateStatus() {\n    var mounting = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var nextStatus = arguments[1];\n\n    if (nextStatus !== null) {\n      // nextStatus will always be ENTERING or EXITING.\n      this.cancelNextCallback();\n      var node = _reactDom2.default.findDOMNode(this);\n\n      if (nextStatus === ENTERING) {\n        this.performEnter(node, mounting);\n      } else {\n        this.performExit(node);\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({ status: UNMOUNTED });\n    }\n  };\n\n  Transition.prototype.performEnter = function performEnter(node, mounting) {\n    var _this2 = this;\n\n    var enter = this.props.enter;\n\n    var appearing = this.context.transitionGroup ? this.context.transitionGroup.isMounting : mounting;\n\n    var timeouts = this.getTimeouts();\n\n    // no enter animation skip right to ENTERED\n    // if we are mounting and running this it means appear _must_ be set\n    if (!mounting && !enter) {\n      this.safeSetState({ status: ENTERED }, function () {\n        _this2.props.onEntered(node);\n      });\n      return;\n    }\n\n    this.props.onEnter(node, appearing);\n\n    this.safeSetState({ status: ENTERING }, function () {\n      _this2.props.onEntering(node, appearing);\n\n      // FIXME: appear timeout?\n      _this2.onTransitionEnd(node, timeouts.enter, function () {\n        _this2.safeSetState({ status: ENTERED }, function () {\n          _this2.props.onEntered(node, appearing);\n        });\n      });\n    });\n  };\n\n  Transition.prototype.performExit = function performExit(node) {\n    var _this3 = this;\n\n    var exit = this.props.exit;\n\n    var timeouts = this.getTimeouts();\n\n    // no exit animation skip right to EXITED\n    if (!exit) {\n      this.safeSetState({ status: EXITED }, function () {\n        _this3.props.onExited(node);\n      });\n      return;\n    }\n    this.props.onExit(node);\n\n    this.safeSetState({ status: EXITING }, function () {\n      _this3.props.onExiting(node);\n\n      _this3.onTransitionEnd(node, timeouts.exit, function () {\n        _this3.safeSetState({ status: EXITED }, function () {\n          _this3.props.onExited(node);\n        });\n      });\n    });\n  };\n\n  Transition.prototype.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n\n  Transition.prototype.safeSetState = function safeSetState(nextState, callback) {\n    // This shouldn't be necessary, but there are weird race conditions with\n    // setState callbacks and unmounting in testing, so always make sure that\n    // we can cancel any pending setState callbacks after we unmount.\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, callback);\n  };\n\n  Transition.prototype.setNextCallback = function setNextCallback(callback) {\n    var _this4 = this;\n\n    var active = true;\n\n    this.nextCallback = function (event) {\n      if (active) {\n        active = false;\n        _this4.nextCallback = null;\n\n        callback(event);\n      }\n    };\n\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n\n    return this.nextCallback;\n  };\n\n  Transition.prototype.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {\n    this.setNextCallback(handler);\n\n    if (node) {\n      if (this.props.addEndListener) {\n        this.props.addEndListener(node, this.nextCallback);\n      }\n      if (timeout != null) {\n        setTimeout(this.nextCallback, timeout);\n      }\n    } else {\n      setTimeout(this.nextCallback, 0);\n    }\n  };\n\n  Transition.prototype.render = function render() {\n    var status = this.state.status;\n    if (status === UNMOUNTED) {\n      return null;\n    }\n\n    var _props = this.props,\n        children = _props.children,\n        childProps = _objectWithoutProperties(_props, ['children']);\n    // filter props for Transtition\n\n\n    delete childProps.in;\n    delete childProps.mountOnEnter;\n    delete childProps.unmountOnExit;\n    delete childProps.appear;\n    delete childProps.enter;\n    delete childProps.exit;\n    delete childProps.timeout;\n    delete childProps.addEndListener;\n    delete childProps.onEnter;\n    delete childProps.onEntering;\n    delete childProps.onEntered;\n    delete childProps.onExit;\n    delete childProps.onExiting;\n    delete childProps.onExited;\n\n    if (typeof children === 'function') {\n      return children(status, childProps);\n    }\n\n    var child = _react2.default.Children.only(children);\n    return _react2.default.cloneElement(child, childProps);\n  };\n\n  return Transition;\n}(_react2.default.Component);\n\nTransition.contextTypes = {\n  transitionGroup: PropTypes.object\n};\nTransition.childContextTypes = {\n  transitionGroup: function transitionGroup() {}\n};\n\n\nTransition.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * A `function` child can be used instead of a React element.\n   * This function is called with the current transition status\n   * ('entering', 'entered', 'exiting', 'exited', 'unmounted'), which can be used\n   * to apply context specific props to a component.\n   *\n   * ```jsx\n   * <Transition timeout={150}>\n   *   {(status) => (\n   *     <MyComponent className={`fade fade-${status}`} />\n   *   )}\n   * </Transition>\n   * ```\n   */\n  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,\n\n  /**\n   * Show the component; triggers the enter or exit states\n   */\n  in: PropTypes.bool,\n\n  /**\n   * By default the child component is mounted immediately along with\n   * the parent `Transition` component. If you want to \"lazy mount\" the component on the\n   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay\n   * mounted, even on \"exited\", unless you also specify `unmountOnExit`.\n   */\n  mountOnEnter: PropTypes.bool,\n\n  /**\n   * By default the child component stays mounted after it reaches the `'exited'` state.\n   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.\n   */\n  unmountOnExit: PropTypes.bool,\n\n  /**\n   * Normally a component is not transitioned if it is shown when the `<Transition>` component mounts.\n   * If you want to transition on the first mount set `appear` to `true`, and the\n   * component will transition in as soon as the `<Transition>` mounts.\n   *\n   * > Note: there are no specific \"appear\" states. `appear` only adds an additional `enter` transition.\n   */\n  appear: PropTypes.bool,\n\n  /**\n   * Enable or disable enter transitions.\n   */\n  enter: PropTypes.bool,\n\n  /**\n   * Enable or disable exit transitions.\n   */\n  exit: PropTypes.bool,\n\n  /**\n   * The duration of the transition, in milliseconds.\n   * Required unless `addEndListener` is provided\n   *\n   * You may specify a single timeout for all transitions like: `timeout={500}`,\n   * or individually like:\n   *\n   * ```jsx\n   * timeout={{\n   *  enter: 300,\n   *  exit: 500,\n   * }}\n   * ```\n   *\n   * @type {number | { enter?: number, exit?: number }}\n   */\n  timeout: function timeout(props) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var pt = _PropTypes.timeoutsShape;\n    if (!props.addEndListener) pt = pt.isRequired;\n    return pt.apply(undefined, [props].concat(args));\n  },\n\n  /**\n   * Add a custom transition end trigger. Called with the transitioning\n   * DOM node and a `done` callback. Allows for more fine grained transition end\n   * logic. **Note:** Timeouts are still used as a fallback if provided.\n   *\n   * ```jsx\n   * addEndListener={(node, done) => {\n   *   // use the css transitionend event to mark the finish of a transition\n   *   node.addEventListener('transitionend', done, false);\n   * }}\n   * ```\n   */\n  addEndListener: PropTypes.func,\n\n  /**\n   * Callback fired before the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEnter: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntering: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entered\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEntered: PropTypes.func,\n\n  /**\n   * Callback fired before the \"exiting\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExit: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exiting\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExiting: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exited\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExited: PropTypes.func\n\n  // Name the function so it is clearer in the documentation\n} : {};function noop() {}\n\nTransition.defaultProps = {\n  in: false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n\n  onEnter: noop,\n  onEntering: noop,\n  onEntered: noop,\n\n  onExit: noop,\n  onExiting: noop,\n  onExited: noop\n};\n\nTransition.UNMOUNTED = 0;\nTransition.EXITED = 1;\nTransition.ENTERING = 2;\nTransition.ENTERED = 3;\nTransition.EXITING = 4;\n\nexports.default = (0, _reactLifecyclesCompat.polyfill)(Transition);"]},"metadata":{},"sourceType":"script"}